object TropicalOrientedMatroid {

# @category Basic properties
# The __rank__ of a given type //type// is the number of connected components of the [[TYPE_GRAPH|type's graph]].
# @param Array<Set<Int>> type
# @return Int
user_method TYPE_RANK :  RANK, N_PHP {	# for some reason this only works if we have N_PHP here (although we certainly don't need it)
	
	my ($self, $j) = @_;
	return rank($j, $self->RANK);
}


# @category Basic properties
# The //i//-the [[APICES|apex]], i.e., the (unique) type whose //i//-th coordinate is [d] (for d=[[RANK]]).
# @param Int i
# @return Array<Set<Int>>
user_method APEX : VERTICES, RANK {
	my ($self, $j) =@_;
	
	my $v=$self->VERTICES;
	foreach my $vertex (@$v) {
		if (@{$vertex->[$j-1]}==$self->RANK) {
			return $vertex;
		}
	}
}


# @category Producing a new TropicalOrientedMatroid
# Returns the __deletion__, i.e., the TropicalOrientedMatroid obtained by deleting some position (hyperplane) //pos//.
# [[N_PHP]] is reduced by one.
# @param int pos the position to be deleted
# @return TropicalOrientedMatroid
#
user_method DELETION : VERTICES, RANK, N_PHP {
	
	my ($self, $pos) = @_;
	
	if ($pos > $self->N_PHP || $pos < 1) {
		die "index out of range";
	}
	
	$pos = $pos-1;
	my @vs = @{$self->VERTICES};
	
	my @r = ();
	for (my $i=0; $i<@vs; ++$i) {
		my @t = ();
		my @curr = @{$vs[$i]};
		for (my $j=0; $j<@curr; ++$j) {
			if ($j != $pos) {
				push(@t,$curr[$j]);
			}
		}
		my $rank = $self->TYPE_RANK(\@t);
		if ($rank==1) {
			push(@r, \@t);
		}
	}
	
	my $t = new TropicalOrientedMatroid(VERTICES=>\@r);
	
	return $t;
}

# @category Producing a new TropicalOrientedMatroid
# Returns the __contraction__, i.e., the TropicalOrientedMatroid obtained by restricting to all types that do not contain //pos//.
# [[RANK]] is reduced by one.
# @param int pos the position to be contracted
# @return TropicalOrientedMatroid
user_method CONTRACTION : TOPES, RANK, N_PHP {
	my ($self, $pos) = @_;
	
	if ($pos > $self->RANK || $pos < 1) {
		die "index out of range";
	}
	
	my @vs = @{$self->TOPES};

	my @r = ();
	LOOP: for (my $i=0; $i<@vs; ++$i) {			# go thru all types
		my @type = @{$vs[$i]};

		my @ntype =();
		for (my $j=0; $j<@type; ++$j) {			# go thru sets in current type			
			my @curr = @{$type[$j]};
			
				if ($curr[0]==$pos) {			# if current set contains pos
					next LOOP;					# go to next type
				} elsif ($curr[0]>$pos) {
					my @x = (); push(@x,$curr[0]-1);
					push(@ntype, \@x);
				} else {
					my @x = (); push(@x, $curr[0]);
					push(@ntype, \@x);
				}
		}
		push(@r, \@ntype);						# add it to return set
	}
	
	my $t = new TropicalOrientedMatroid(TOPES=>\@r);
	
	return $t;
}


# @category Producing a new TropicalOrientedMatroid
# Produces a new TropicalOrientedMatroid by __placing__ vertices in
# &Delta;<sup>n-1</sup> &times; &Delta;<sup>d-1</sup>, where n=[[N_PHP]], d=[[RANK]].
# The result will be a tropical oriented matroid with parameters (n+1,d); i.e., the [[N_PHP|number of pseudohyperplanes]] is increased by 1.
# It will be non-realisable if and only if the input was. 
# @param Array<Int> perm permutation of [d], default: [1, ..., d]
# @return TropicalOrientedMatroid
user_method N_PLACING : VERTICES, RANK, DIM, N_PHP {
	
	my ($self, $perm) = @_;
	my $d = $self->RANK;
	
	my @p;
	if (defined($perm)) {
		@p = @$perm;
		if (@p != $d) {
			die "argument is not a permutation of [$n].";
		}
	} else {
		@p=();
		for (my $i=1; $i<=$d; ++$i) {
			push(@p,$i);
		}
	}
	my @v = @{$self->VERTICES};

	my @r = ();		# will contain new vertices
	
	my @used = ();	# already used values from [d]
	my @oldused = ();
	foreach (@p) {
		@oldused = @used;
		
		my $curr = $_;
		push(@used, $curr);
		foreach (@v) {

			if (my $ref = $self->typeminus($_,\@oldused)){
				my @x = sort(@used);
				push(@$ref, \@x);

				if ($self->TYPE_RANK($ref)==1) {
					push(@r, $ref);
				}
			}
		}
	}
	my $t = new TropicalOrientedMatroid(VERTICES=>\@r);
	return $t;
}

# @category Producing a new TropicalOrientedMatroid
# Produces a new TropicalOrientedMatroid by __placing__ vertices in
# &Delta;<sup>n-1</sup> &times; &Delta;<sup>d-1</sup>, where n=[[N_PHP]], d=[[RANK]].
# The result will be a tropical oriented matroid with paramters (n,d+1); i.e., the [[RANK|rank]] is increased by 1.
# It will be non-realisable if and only if the input was.
# @param Array<Int> perm permutation of [n], default: [1, ..., n]
# @return TropicalOrientedMatroid
user_method D_PLACING : VERTICES, RANK, DIM, N_PHP {
	my ($self, $perm) = @_;
	
	my $n = $self->N_PHP;
	my $d = $self->RANK;

	my @p;
	if (defined($perm)) {
		@p = @$perm;
		if (@p != $n) {
			die "argument is not a permutation of [$n].";
		}
	} else {
		@p=();
		for (my $i=1; $i<=$n; ++$i) {
			push(@p,$i);
		}
	}

	my @v = @{$self->VERTICES};
	my @r = ();		# will contain new vertices

	my @old_height=@v;
	my @new_height=();
	foreach (@p) {
		
		my $curr = $_;

		foreach (@old_height) {
		
			my @curr_cell=@$_;
			my @new_cell=@curr_cell;
			my @entry=@{$curr_cell[$curr-1]};
			push(@entry,$d+1);	# add new entry d+1 to the current position
			my @new_entry=sort(@entry);
			$new_cell[$curr-1]=\@new_entry;
			push(@r,\@new_cell);
			
			my @new_cell=@curr_cell;	# replace current position by {d+1}
			my @tmp=($d+1);
			$new_cell[$curr-1]=\@tmp;
			if (rank(\@new_cell,$d+1)==2) { push(@new_height,\@new_cell); }
		}
		@old_height=@new_height;
		@new_height=();
	}
	my $t = new TropicalOrientedMatroid(VERTICES=>\@r);
	return $t;

}


# @category Axioms
# Two types are __comparable__ if their comparability graph is acyclic.
# @param Array<Set<Int>> type1
# @param Array<Set<Int>> type2
# @return Bool
user_method COMPARABLE : RANK{
	my ($self, $type1, $type2) = @_;
	my $t1 = @{$type1};
	my $t2 = @{$type2};
	if ($t1 != $t2) {
		die "input types do not have correct length";
	}

	my $r= comparable($type1, $type2, $self->RANK);
	if ($r) {return 1;} else {return 0;}
}

# @category Axioms
# The __elimination__ of two types //A// and //B// with respect to a position //j// is a type C such that C<sub>j</sub>=A<sub>j</sub>&cup;B<sub>j</sub> and C<sub>i</sub>&isin;{A<sub>i</sub>, B<sub>i</sub>, A<sub>i</sub>&cup;B<sub>i</sub>} for each i&isin;[d] (where d=[[RANK]]).
# @param Array<Set<Int>> A
# @param Array<Set<Int>> B
# @param Int j
# @return Array<Set<Int>> C
user_method ELIMINATION : TYPES, N_PHP {
	my ($self, $type1, $type2, $j) = @_;
	my $t1 = @{$type1};
	my $t2 = @{$type2};
	if ($t1 != $t2 or $t1 !=$self->N_PHP) {
		die "input types do not have correct length";
	}
	if ($j<1 or $j>$self->N_PHP) {
		die "position must be contained in [$self->N_PHP]."
	}
	
	$j=$j-1;

	my $s1=new Set<Int>($type1->[$j]);
	my $s2=new Set<Int>($type2->[$j]);
	OUTERLOOP: foreach (@{$self->TYPES}) {
		my $set = new Set<Int>($_->[$j]);
		unless ($set==$s1+$s2) {
			next;
		}
		my $cur = $_;
		for (my $i=0; $i<$self->N_PHP; ++$i) {
			unless (elim_sat($type1->[$i], $type2->[$i], $cur->[$i])) {
				next OUTERLOOP;
			}
		}
		
		return $cur;
	}
	return 0;
}
weight 2.0;


user_method FAST_ELIMINATION : VERTICES, N_PHP, RANK {

	my ($self, $type1, $type2, $j) = @_;
	my $t1 = @{$type1};
	my $t2 = @{$type2};
	if ($t1 != $t2 or $t1 !=$self->N_PHP) {
		die "input types do not have correct length";
	}
	if ($j<1 or $j>$self->N_PHP) {
		die "position must be contained in [$self->N_PHP]."
	}
	
	$j=$j-1;

	my $s1=new Set<Int>($type1->[$j]);
	my $s2=new Set<Int>($type2->[$j]);
		
	OUTERLOOP: foreach (@{$self->VERTICES}) {
		
		if (contains($_->[$j], $s1+$s2)) {
			
			my $cur = $_;
			
			for (my $i=0; $i<$self->N_PHP; ++$i) {	#go thru sets in  type
				if (!elim_contains($type1->[$i],$type2->[$i], $cur->[$i])) {
					next OUTERLOOP;
				}
			}
			# if we are here then the current vertex contains sth that could be the elimination
			
			my @op = ();
			push(@op,$s1+$s2);
			my $r=$self->REFINEMENT($cur,\@op);
			return $r;
		}
	}
	
	return 0;

}
weight 1.5;



sub elim_sat {
	my ($t1, $t2, $c) = @_;

	my $s1=new Set<Int>(@{$t1});
	my $s2=new Set<Int>(@{$t2});
	my $s=new Set<Int>(@{$c});

	return ($s==$s1 or $s==$s2 or $s==$s1+$s2);
}

sub elim_contains {
	my ($t1, $t2, $c) = @_;

	my $s1=new Set<Int>(@{$t1});
	my $s2=new Set<Int>(@{$t2});
	my $s=new Set<Int>(@{$c});

	return (contains($s,$s1) or contains($s,$s2) or contains($s,$s1+$s2));
}


# @category Axioms
# Returns true if the given type //type// is contained in the tropical oriented matroid.
# @param Array<Set<Int>> type
# @return Bool
user_method CONTAINS : VERTICES, N_PHP {
	my ($self, $type) = @_;
		
	my @vs = @{$self->VERTICES};
	my @t = @{$type};
	my $t = @t;
	
	LOOP: for (my $i=0; $i<@vs; ++$i) {		# go thru all vertices
		my @v=@{$vs[$i]};
	
		if (@v!=$t) {
			die "input type does not have correct length";
		}
		
		for (my $j=0; $j<@t; ++$j) {	#go thru sets in input type
			if (!contains($v[$j],$t[$j])) {
				next LOOP;
			}
		}
		return 1;
	}
	return 0;
}
precondition : GENERAL_POSITION;
weight 2.00;

# @category Axioms
# Returns the __refinement__ of a given type //type// with respect to an ordered partition //ord_part// of [d],
# where d=[[RANK]].
# @param Array<Set<Int>> type
# @param Array<Set<Int>> ord_part an ordered partition of [d]
# @return Array<Set<Int>>
# 
user_method REFINEMENT {
	my ($self, $type, $ordp) = @_;
	my @t = @{$type};
	my @o = @{$ordp};
	
	my @r=();
	
	TYPE: foreach (@t) {			# go thru input type
		my $a=new Set<Int>($_);
		foreach (@o) {		# go thru sets in ordered partition
			my $b=new Set<Int>($_);
			my @i= @{$a*$b};#@{intersect($a,$_)};
			if (@i) {
				push(@r,\@i);
				next TYPE;
			}
		}
		push(@r,$a);	# take care of the case where we do only have a partial ordered partition (i.e., last set is omitted)
	}
	return new Array<Set<Int>>(@r);
}



# @category Basic properties
# Returns the type graph of a given type.
# The vertices correspond to the elements in [d];
# two nodes are connected by an edge whenever there is an entry
# in //type// containing them both.
# @param Array<Set<Int>> type
# @return graph::Graph<Undirected>
user_method TYPE_GRAPH : RANK{

	my ($self, $type) = @_;
	my @t=@$type;
	my $d = $self->RANK;
	
	my $r=new props::Graph($d);

	foreach (@t) {
		my @s=@$_;
		for (my $i=0; $i<@s; ++$i) {	# go thru one set
			for (my $j=$i+1; $j<@s; ++$j) {
				my $x=$s[$i];
				my $y=$s[$j];
				$r->edge($x-1,$y-1);
			}
		}
	}
	return new graph::Graph(ADJACENCY=>$r);
}


# @category Pseudohyperplanes
# Returns the set of vertices of the //j//-th pseudohyperplane.
# @param Int j
# @return Array<Set<Int>>
user_method PSEUDOHYPERPLANE : VERTICES, N_PHP {
	my ($self, $j) = @_;
	my @r=();
	
	my @v=@{$self->VERTICES};
	
	foreach (@v) {		# go thru VERTICES
		my @s=@{$_};
		if (@{$s[$j-1]} >= 2) {
			push(@r,\@s);
		}
	}
	return \@r;
}


# Checks whether $set contains $subset as a subset -- to be replaced by common function incl.
sub contains {						
	my ($set, $subset) = @_;
	my @s = @{$set};
	my @ss = @{$subset};
	LOOP: for (my $i=0; $i<@ss; ++$i) {
		my $a=$ss[$i];
		foreach (@s) {
			if ($_ == $a) {
				next LOOP;
			}
		}
		return 0;
	}
	return 1;
}	


# compute the complement of a set s in [d]
sub compl {
	my ($s, $d) = @_;
	my @s = @$s;
	
	my @r = ();
	for (my $i=1; $i<=$d; ++$i) {
		unless(contains(@s,($i))) {
			push(@r, $i);
		}
	}
	return \@r;
}

# @category Type manipulation
# Takes a type //type// and subtracts a set //indices// from every position. Return the result of this operation, or 0 if the result is not a type, i.e., if there is an empty position.
# @param Array<Set<Int>> type
# @param Set<Int> indices
# @return Array<Set<Int>> or 0 if not a type
user_method typeminus {
	shift;
	my ($type, $indices) = @_;
	my @t = @{$type};
	my @i = @$indices;
	my @r=();
	foreach (@t) {
		my @nv = ();
		if (contains(\@i, $_)) {
			return 0;
		} else {
			foreach (@{$_}) {
				my @tmp = ($_);
				unless(contains(\@i, \@tmp)) {
					push(@nv, $_);
				}
			}
		}
		push(@r, \@nv);
	}
	return \@r;
}



# @category Type manipulation
# Returns a list of all subtypes of a given type //type//.
# @param Array<Set<Int>> type
# @return Array<Array<Set<Int>>>
user_method all_subtypes {
	my ($self, $t)=@_;

	my $d=$self->RANK;

	my $set=range(1, $d);
	my @op=();
	
	return rec_subtypes($self, $t, $set, @op);
}


sub rec_subtypes {
	my ($tom, $t, $set, @op)=@_;
	
	my $list=new Set<Array<Set<Int>>>;
	my $tmp=new Array<Set>($t);
	$list+=$tmp;
	
	my $s=enumerate_subsets($set);
#	print "all subsets of $set:\n@$s\n\n";
	
	foreach (@$s) { # now go thru all subsets of the set of remaining entries...
#		print "current subset of $set: $_\n";

		# and choose one as the next set in the ordered partition
		my $new_set=$set-$_;
		my @new_op=@op;
		push(@new_op,$_);
#		print "type: ";
#		foreach (@$t) { print "{@$_} ";} print "\n";
#		print "partition: @new_op\n";

		my $new_t=$tom->REFINEMENT($t,\@new_op);
#		print "refinement: $new_t";
	
		unless(type_equals($t,$new_t)) {
			my $r=rec_subtypes($tom, $new_t, $new_set, @new_op);
			$list+=$r;
		}
	}
	return $list;
}

sub type_equals {
	my ($t1,$t2)=@_;
	
	for (my $i=0; $i<@$t1; ++$i) {
		my $s1=new Set<Int>($t1->[$i]);
		my $s2=new Set<Int>($t2->[$i]);
		unless ($s1==$s2){
			return 0;
		}
	}
	return 1;
}





# @category Hidden
user_method N_JAVASCRIPT {
	print "Oh, you're very funny. Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_PERL {
	print "I thought you'd try that.";
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_FORTRAN {
	print "Rolf? Is this you? Math without FORTRAN? I'm in! Honestly: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_JAVA {
	print "Hey, you found another programming language. Congratulations!";
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_SHAKESPEARE {
	print "Fun fact to know: Although Shakespeare is known to have used at least six or seven different spellings of his name, the one you just typed, which is most commonly used nowadays, was not among them.";
}

# @category Hidden
user_method N_WHITESPACE {
	print "Well, this is getting a bit too absurd now, don't you think.";
}

# @category Hidden
user_method N_PASCAL {
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_HASKELL {
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}


# @category Hidden
user_method N_CPLUSPLUS {
	print "Well, that was so obvious.";
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_PYTHON {
	print "In your dreams...";
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_HTML {
	print "Oh, come on, html isn't even a programming language.";
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}

# @category Hidden
user_method N_CSS {
	print "Oh, come on, css isn't even a programming language.";
	print "Btw: php in N_PHP stands for PseudoHyperPlane.";
}


}  # end TropicalOrientedMatroid

