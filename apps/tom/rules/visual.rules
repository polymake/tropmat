
package Visual::TropicalOrientedMatroid;
use Polymake::Struct (
   [ '@ISA' => 'Container' ],
   '$TropicalOrientedMatroid',
);




object TropicalOrientedMatroid {

# @category Visualization
# Visualizes all pseudohyperplanes inside the mixed subdivision.
# @return Visual::TropicalOrientedMatroid
user_method VISUAL_ALL : VERTICES, DIM, N_PHP{
	my ($self)=@_;
	
	compose($self->VISUAL_MIXED_SUBDIVISION(EdgeColor=>'grey', FacetStyle=>'hidden'), $self->VISUAL_PHPS('All'));
}
precondition : DIM {$this->DIM<=3, $this->DIM>=2}

# @category Visualization
# Visualises the given dual pseudohyperplanes in different colours.
# @param Set<Int> phps
# @return Visual::TropicalOrientedMatroid
user_method VISUAL_DUAL_PHPS : VERTICES, DIM, N_PHP{
	my ($self, $hps) = @_;
	my @h;
	if ($hps=='All') {
		@h=();
		for (my $i=1; $i<=$self->N_PHP; ++$i){
			push(@h,$i);
		}
	} else {
		@h = @{$hps};
	}

	my $angle=360/(@h);
	my $count=0;
	
	my $d=$self->DIM;

	if ($d >= 4) {
		die "don't know how to visulize $d-dimensional polytopal complex";
	}

	my @cells_visual=();

	foreach (@h) {
		my $php=$_;
		my $vertices=$self->PSEUDOHYPERPLANE($php);
		my $hue=$angle*$count;

		if ($d == 2) {
			foreach (@{$vertices}) {
				foreach (dual_of_cell($_,$php,$d)) {
					my $hsv=new HSV($hue,1,1);
					my $rgb=new RGB($hsv);
#					push(@cells_visual,(my $pv=$_->VISUAL( VertexStyle=>'hidden', EdgeColor=>$hsv)));
					push(@cells_visual,(my $pv=$_->VISUAL( VertexStyle=>'hidden' )));
				}
			}
		}
		
		if ($d == 3) {
			foreach (@{$vertices}) {
				foreach (dual_of_cell($_,$php,$d)) {
					my $temp=ortho_project($_);
					push(@cells_visual,(my $pv=$temp->VISUAL( VertexStyle=>'hidden', FacetColor=>new HSV($hue,1,1) )));
				}
			}
		}
		++$count;
	}

   visualize(new Visual::TropicalOrientedMatroid( Name => "Dual",
					TropicalOrientedMatroid => $self,
					@cells_visual));
}
precondition : DIM {$this->DIM<=3, $this->DIM>=2}


# @category Visualization
# Visualizes the //i//-th dual pseudohyperplane.
# @param Int i
# @return Visual::TropicalOrientedMatroid
user_method VISUAL_DUAL_PHP : VERTICES, DIM {
	my ($self, $php)=@_;
	
	my $d=$self->DIM;
	my $vertices=$self->PSEUDOHYPERPLANE($php);
	
	if ($d >= 4) {
		die "don't know how to visulize $d-dimensional polytopal complex";
	}

	my @cells_visual=();

    if ($d == 2) {
    	foreach (@{$vertices}) {
    		foreach (dual_of_cell($_,$php,$d)) {
    			push(@cells_visual,(my $pv=$_->VISUAL( VertexStyle=>'hidden' )));
    		}
    	}
    }
    
    if ($d == 3) {
    	foreach (@{$vertices}) {
    		foreach (dual_of_cell($_,$php,$d)) {
    			my $temp=ortho_project($_);
    			push(@cells_visual,(my $pv=$temp->VISUAL( VertexStyle=>'hidden' )));
    		}
    	}
    }
    
   visualize(new Visual::TropicalOrientedMatroid( Name => "Dual",
					TropicalOrientedMatroid => $self,
					@cells_visual));

}
precondition : DIM { $this->DIM<=3, $this->DIM>=2 }


# @category Visualization
# Visualizes the mixed subdivision of n&Delta;<sup>d-1</sup> (d=[[DIM]] and n=[[N_PHP]])
# corresponding to the tropical oriented matroid.
# @return Visual::TropicalOrientedMatroid
user_method VISUAL_MIXED_SUBDIVISION(%Visual::Polygons::decorations) : VERTICES, DIM {
	my ($self,$decor)=@_;
	my $d=$self->DIM;
	my $vertices = $self->VERTICES;


    if ($d >= 4) {
		die "don't know how to visualize the mixed subdivision of a $d-simplex\n";
    }
 
#    $self->Name="Mixed subdivision of ($d-1)-simplex corresponding to ".$self->name;
	
	my @cells_visual = ( );
 	
   	if ($d <= 2) {
		foreach (@{$vertices}) {
    		my $mink = minkowski_cell($_, 3);		
	     	push (@cells_visual, (my $pv = $mink->VISUAL( VertexStyle=>'hidden', $decor )));
		}
	}
	elsif ($d == 3) {
		foreach (@{$vertices}) {
			my $s = minkowski_cell($_, 4);
			#print "Dim: $s->DIM\n";
    		my $mink = ortho_project($s);		
	     	push (@cells_visual, (my $pv = $mink->VISUAL( VertexStyle=>'hidden', $decor )));
		}
	}

   visualize(new Visual::TropicalOrientedMatroid( Name => "Mixed subdivision",
					TropicalOrientedMatroid => $self,
					@cells_visual));
}
precondition : DIM { $this->DIM<=3 }


# @category Visualization
# Visualizes the given pseudohyperplanes in the mixed subdivision 
# of n&Delta;<sup>d-1</sup> (d=[[DIM]] and n=[[N_PHP]])
# corresponding to the tropical oriented matroid.
# @param Set<Int> phps keyword All chooses all pseudohyperplanes
# @return Visual::TropicalOrientedMatroid
user_method VISUAL_PSEUDO_HYPERPLANES: VERTICES, DIM {
	my ($self, $hps)=@_;
	my @h;
	if ($hps=='All') {
		@h=();
		for (my $i=1; $i<=$self->N_PHP; ++$i){
			push(@h,$i);
		}
	} else {
		@h = @{$hps};
	}
	my $d=$self->DIM;
	
	my $col;	# colour difference value
	 if (@h==1) {$col=1;} else {$col=1/(@h-1);}	
	my $count=0;	# hp counter

    if ($d >= 4) {
		die "don't know how to visualize the mixed subdivision of a $d-simplex\n";
    }

	my @cells_visual = ( );
	
	foreach (@h) {
		my $vertices = $self->PSEUDOHYPERPLANE($_);
 	
	   	if ($d <= 2) {
			foreach (@{$vertices}) {
    			my $mink = shift_php(minkowski_cell($_, 3), $count+1);
    			
    			my $colour=$count*$col;
	     		push (@cells_visual, (my $pv = $mink->VISUAL( VertexStyle=>'hidden', EdgeColor=>'red', FacetColor=>new RGB($colour,$colour,$colour) )));
			}
		}
		elsif ($d == 3) {
			foreach (@{$vertices}) {
				my $s = minkowski_cell($_, 4);
				#print "Dim: $s->DIM\n";
    			my $mink = ortho_project($s);		
	    	 	push (@cells_visual, (my $pv = $mink->VISUAL(  )));
			}
		}
		$count++;
	}

   visualize(new Visual::TropicalOrientedMatroid( Name => "Pseudohyperplanes",
					TropicalOrientedMatroid => $self,
					@cells_visual));
}
precondition : DIM { $this->DIM<=3 }



# projects a 3-dim standard simplex in R4 to R3.
sub ortho_project {
	my ($poly) = @_;
	my @vs = @{$poly->VERTICES};
	my @nvs = ();
	foreach (@vs) {
		my @v=@{$_};
		#print "@v";
		
		my @nv = ();
		$nv[0]=1;
		for (my $i=1; $i<4; ++$i) {
			$nv[$i] = $v[$i] - 1/3*$v[4];
		}
		#print "		@nv\n";
		push(@nvs,\@nv);
	}
	
	my $r = new polytope::Polytope<Float>(VERTICES=>\@nvs);
	return $r;
}

# shifts pseudohyperplanes so that one can see them
sub shift_php {
	my ($poly, $number)=@_;
	my @vs = @{$poly->VERTICES};
	my @nvs = ();	# new vertices
	foreach (@vs) {
		my @v=@{$_};
		
		my @nv = ();	# new vertex
		$nv[0]=1;
		for (my $i=1; $i<4; ++$i) {
			$nv[$i] = $v[$i]+$number*.1;
		}
		push(@nvs,\@nv);
	}
	
	my $r = new polytope::Polytope<Float>(VERTICES=>\@nvs);
#	my $r = new polytope::Polytope<Float>(VERTICES=>\@vs);

	return $r;
	

}


sub dual_of_cell {
#	print "dual_of_cell\n";
	my ($v, $php, $d) = @_;
	# v is the current vertex, php the index of the php under consideration and d the dimension
	my $entry = $v->[$php-1];
	# entry is the current entry

	my @dual_cells=();	# will contain dual cells

	for (my $i=0; $i<@$entry-1; ++$i) {
		for (my $j=$i+1; $j<@$entry; ++$j) {
			my @entry=@$entry;
			my $p=get_base_cell($entry[$i],$entry[$j],$entry,$d);
			
			my $m=$p;
			my $size=@$v;
			for (my $k=0; $k<@$v; ++$k) {
				unless ($k+1==$php) {
					my @vs=@{$v->[$k]};
					my $tmp=simplex_face($d+1,@vs);
					$m = polytope::minkowski_sum(1, $m, 1, $tmp);
				}
			}
			push(@dual_cells, $m);
		}
	}
	return @dual_cells;
}

sub get_base_cell {
	# any cell in the dual of a simplex is defined by two edges
	my ($i,$j,$entry,$d)=@_;
	my @set=sort($i,$j);
	my $rest=setminus($entry,\@set);
	my $all_ss=all_subsets($rest,\@set);
	my @vertices=();
	
	foreach (@$all_ss) {
		push(@vertices,center_of_cell($d,$_));
	}
	my $p=new Polytope<Float>(VERTICES=>\@vertices);
	return $p;
}

# all subsets of a given set containing a given subset
sub all_subsets {
	my ($set, $start)=@_;
	my @s=@$set;
	my @ret=(); push(@ret, $start);
	
	my @r=@{all_ss_rec($set, \@ret)};
	my $size=@r;
	return \@r;
}
sub all_ss_rec {
#	print "all_ss_rec\n";
	my ($set, $sets)=@_;
#	print "set: @$set\n";
	unless (@$set) { return $sets; }
	
	my $next_elt= pop(@$set);
	my @sets = @{all_ss_rec($set, $sets)};
	my $size=@sets;
#	print "sets: $size\n";
#	foreach(@sets){
#		print "@$_";
#	}print "\n";
	
	my @ret=@sets;
	foreach (@sets) {
		my @curr_set=@$_;
		my @copy=@curr_set;
		push(@copy,$next_elt);
		my @next_set=sort(@copy);
		push(@ret,\@next_set);
	}
	return \@ret;
}

# set difference
sub setminus {
	my ($set, $ss)=@_;
	my @ret=();
	foreach (@$set) {
		unless (cont_elt($ss,$_)) {	push(@ret, $_);	}
	}
	return \@ret;
}

# the center of a given simplex face
sub center_of_cell {
	my ($d, $cell) = @_;
	my $sf=simplex_face($d+1, @$cell);
	my $vb= $sf->VERTEX_BARYCENTER;
	return $vb;
}


}	# end TropicalOrientedMatroid



# Local Variables:
# mode: perl
# c-basic-offset:3
# End:
